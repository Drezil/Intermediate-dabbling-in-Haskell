\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx} % Bilder
\usepackage{wrapfig} % Umflussbilder
\usepackage{multicol} % Multiple columns
\usepackage{minted} % Haskell source code
\usepackage{framed} % Frames around source code
\usepackage[framemethod=tikz]{mdframed} % Frames
\usepackage{verbatim} % \begin{comment}...\end{comment}
\usepackage{etoolbox} % manipulate minted
\AtBeginEnvironment{minted}{\fontsize{10}{10}\selectfont}
\AfterEndEnvironment{minted}{}

\mdfdefinestyle{fancy}{
  roundcorner=5pt,
  linewidth=4pt,
  linecolor=red!80,
  backgroundcolor=red!20
}
\newmdenv[style=fancy]{important}

% Stuff for Beamer
\beamertemplatenavigationsymbolsempty
\usetheme{Warsaw}

\title{Intermediate Dabbling in Haskell}

\begin{document}

%  \usebackgroundtemplate{\includegraphics[width=\paperwidth,height=\paperheight]{1.jpg}} 
  
%----------------------------------------------------------------------------------------  

  \begin{frame}
  \begin{center}
    \Huge\textbf{Intermediate Functional Programming in Haskell}\\ \bigskip
    \LARGE Universität Bielefeld, Sommersemester 2015\\ \bigskip
    \large Jonas Betzendahl \& Stefan Dresselhaus
    \end{center}
  \end{frame}

%----------------------------------------------------------------------------------------  
\begin{frame}[allowframebreaks]{Outline}
\frametitle{Übersicht}
\tableofcontents[hideallsubsections]
\end{frame}

\section{State-Monad}

\subsection{Beispiele}
\begin{frame}[fragile]
Wir hatten in der letzten Vorlesung die State-Monade kurz angesprochen.\\
Heute wenden wir uns der Definition zu und werden herausfinden, wie man noch weiter abstrahieren kann.\\
\end{frame}

\begin{frame}[fragile]
Beispiel:
\begin{minted}{haskell}
countme :: a -> State Int a
countme a = do
              modify (+1)
              return a

example :: State Int Int
example = do
              x <- countme (2+2)
              y <- return (x*x)
              z <- countme (y-2)
              return z

examplemain = runState example 0
-- -> (14,2), 14 = wert von z, 2 = interner counter
\end{minted}
\end{frame}

\begin{frame}[fragile]
Beispiel 2:
\begin{minted}{haskell}
module Main where
import Control.Monad.State
type CountValue = Int
type CountState = (Bool, Int)
 
startState :: CountState
startState = (False, 0)

play :: String -> State CountState CountValue
--play  ...

\end{minted}
\end{frame}

\begin{frame}[fragile]
\begin{minted}{haskell}
play []     = do
              (_, score) <- get
              return score
play (x:xs) = do
 (on, score) <- get
 case x of
   'C' -> if on then put (on, score + 1) else put (on, score)
   'A' -> if on then put (on, score - 1) else put (on, score)
   'T' -> put (False, score)
   'G' -> put (True, score)
   _   -> put (on, score)
 playGame xs

main = print $ runState (play "GACAACTCGAAT") startState
-- -> (-3,(False,-3))
\end{minted}
\end{frame}

\subsection{Definition}
\begin{frame}[fragile]
Die State-Monade \glqq packt\grqq \ einen State in jeden Funktionsaufruf:
\begin{minted}{haskell}
newtype State s a = State { runState :: s -> (a,s) }

foo :: a -> State s b
foo :: a -> (s -> (b,s))
foo :: a -> s -> (b,s)
\end{minted}
\pause
Wir sehen, dass eine Funktion, die in die State-Monade aufgewertet wurde einfach nur ein weiteres Funktionsargument (den State \texttt{s}) mitgegeben wird und wir statt dem Ergebnis \texttt{b} ein \texttt{(b,s)} bekommen, was den neuen Zustand enthält.
\end{frame}

\begin{frame}[fragile]
Man kann sich die State-Monade als Berechnung vorstellen, die noch nicht ausgeführt werden kann, weil der initiale State nicht gesetzt ist. Dies spiegelt sich auch in der Funktor-Instanz wieder:
\pause
\begin{minted}{haskell}
instance Functor (State s) where
  fmap f (State rs) = State $ \s -> 
                      let (a,s') = rs s in (f a, s')
\end{minted}
\pause
Wir sehen, dass wir erst mit \texttt{rs s} den State, den wir bekommen \glqq ausführen\grqq \ müssen um ein \texttt{a} zu generieren, auf das wir die Funktion anwenden können.\\
Anschließend verpacken wir in unserem Ergebnis den modifizierten State und die angewendete Funktion.\\
\pause
Wichtig ist hier, dass wir wieder eine Funktion in \texttt{State} verpackt zurückgeben müssen, die einen State nimmt:
\begin{minted}{haskell}
newtype State s a = State { runState :: s -> (a,s) }
\end{minted}

\end{frame}

\begin{frame}[fragile]
Ganz analog funktioniert die Applicative-Instanz:
\begin{minted}{haskell}
instance Applicative (State s) where
    pure a = State $ \s -> (a,s)
    (State rs) <*> (State rest) =
                State $ \s ->
                      let (f,s') = rs s
                          (a,s'') = rest s'
                      in
                          (f a,s'')
\end{minted}
\pause
Hier müssen wir den State 2x ausführen. Einmal um an das f zu kommen und dann verketten wir dies mit der restlichen State-Berechnung um auch noch an unser a zu kommen. Zurück geben wir den doppelt bearbeiteten State und den bearbeiteten Wert.\\
\pause
Wichtig ist hier die Reihenfolge! Wir hätten es auch umdrehen können:
\begin{minted}{haskell}
let (f,s'') = rs s'
    (a,s') = rest s
in
    (f a,s'')
\end{minted}
allerdings arbeitet \texttt{<*>} immer von links nach rechts!
\end{frame}

\begin{frame}[fragile]
Am wichtigsten ist die Monad-Instanz:
\begin{minted}{haskell}
instance Monad (State s) where
    return a = State $ \s -> (a,s)
    (State rs) >>= f =
                State $ \s ->
                      let (a,s') = rs s
                          (State rs') = f a
                      in
                          rs' s'
\end{minted}
\pause
Wir müssen wieder zuerst den State ausführen um an unser \texttt{a} zu gelangen. Danach können wir unsere Funktion \texttt{f} ausführen um eine neue Funktion zu bekommen, die wir auch aus dem State auspacken. Eine kleine Anwendung des erhaltenen States hierauf gibt uns schlussendlich unser Ergebnis.
\end{frame}

\section{Monad-Transformer}

\subsection{Beispiel}
\begin{frame}[fragile]
Wir hatten letzte Woche die Maybe-Monade mit dem folgenden Anwendugsfall:
\begin{minted}{haskell}
f = do
      folder <- getInbox
      mail   <- getFirstMail folder
      header <- getHeader mail
      return header
\end{minted}
Nun möchten wir aus irgendeinem Grund (Logging, Netzwerk, ..) zwischen dem \texttt{getInbox} und dem \texttt{getFirstMail} eine IO-Aktion ausführen.\\
~\\
Problem: \texttt{IO /= Maybe}\\
\pause
Als Konsequenz können wir die do-notation nicht verwenden - wir fallen also wieder zurück auf die hässliche Notation:
\end{frame}

\begin{frame}[fragile]
\begin{minted}{haskell}
f :: IO (Maybe Header)
f = case getInbox of
      (Just folder) -> 
          do
            putStrLn "debug"
            return $ case getFirstMail folder of
              (Just mail) -> 
                  case getHeader mail of
                    (Just head) -> return head
                    Nothing     -> Nothing
              Nothing     -> Nothing
      Nothing       -> return Nothing
\end{minted}
\end{frame}

\begin{frame}[fragile]
Dieser Code ist ohne Frage hässlich. Stellt sich die Frage, ob wir nicht soetwas, wie \texttt{MaybeIO} bauen können, sodass wir wieder do-notation verwenden können.\\
\pause
Also kombinieren wir es (ähnlich zur State-Monade):
\begin{minted}{haskell}
data MaybeIO a = MaybeIO { runMaybeIO :: IO (Maybe a) }
\end{minted}
\pause
Dieses liefert uns 2 Funktionen:
\begin{minted}{haskell}
MaybeIO    :: IO (Maybe a) -> MaybeIO a
runMaybeIO :: MaybeIO a -> IO (Maybe a)
\end{minted}
Also eine Funktion, um in unsere neue Monade zu kommen und eine Funktion um dieses wieder Rückgängig zu machen.
\end{frame}

\subsection{F/A/M}
\begin{frame}[fragile]
Fangen wir mit der Functor-Instanz an:
\begin{minted}{haskell}
instance Functor MaybeIO where
  fmap f input = wrapped
               where
                 unwrapped = runMaybeIO input
                 -- IO (Maybe a) auspacken
                 fmapped = fmap (fmap f) unwrapped
                 -- erstes fmap mapped durch IO,
                 -- zweites fmap durch Maybe
                 wrapped = MaybeIO fmapped
                 -- einpacken in den richtigen Typen
\end{minted}
\pause
oder kurz:
\begin{minted}{haskell}
instance Functor MaybeIO where
  fmap f = MaybeIO . fmap (fmap f) . runMaybeIO
\end{minted}
\end{frame}

\begin{frame}[fragile]
Applicative:
\begin{minted}{haskell}
instance Applicative MaybeIO where
  pure    = MaybeIO . return . Just
            -- in Just packen, mit return in IO heben
            -- und den Typen mit MaybeIO aliasen
  f <*> x = MaybeIO $ (<*>) <$> f' <*> x'
            where
              f' = runMaybeIO f -- IO (Maybe f)
              x' = runMaybeIO x -- IO (Maybe x)
\end{minted}
Das erste \texttt{(<*>)} ist Applicative auf Maybe und es wird in Applicative \texttt{<*>} von IO hineingemappt.
\end{frame}

\begin{frame}[fragile]
Monad:
\begin{minted}{haskell}
instance Monad MaybeIO where
  return = pure
  x >>= f = MaybeIO $ x''
            where
              x' = runMaybeIO x
              x'' = x' >>= runMaybeIO . mb . fmap f
              mb :: Maybe (MaybeIO a) -> MaybeIO a
              mb (Just a) = a
              mb Nothing = MaybeIO $ return Nothing
\end{minted}
Zuerst packen wir das MaybeIO aus. \texttt{fmap f} bringt uns ein Maybe (MaybeIO a), welches wir mittels der Hilfsfunktion \texttt{mb} auspacken oder einen leeren Wert konstruieren.\\
Dieses jagen wir noch durch runMaybeIO um wieder ein \texttt{IO (Maybe a)} zu bekommen, auf das wir dann den \texttt{>==}-Operator von IO anwenden können. Das Ergebnis verpacken wir noch in \texttt{MaybeIO} und sind fertig.
\end{frame}

\subsection{Beispiel revisited}
\begin{frame}[fragile]
Da wir nun eine Monade definiert haben, können wir ja wieder do nutzen:
\begin{minted}{haskell}
f = do
     i <- getInbox
     putStrLn "debug"
     m <- getFirstMail i
     h <- getHeader m
     return h
\end{minted}
\end{frame}
\begin{frame}[fragile]
Allerdings:
\begin{minted}{bash}
    Couldn't match type ‘Maybe’ with ‘MaybeIO’
    Expected type: MaybeIO Inbox
      Actual type: Maybe Inbox
    In a stmt of a 'do' block: in <- getInbox

    Couldn't match type ‘IO’ with ‘MaybeIO’
    Expected type: MaybeIO ()
      Actual type: IO ()
    In a stmt of a 'do' block: putStrLn "debug"

    Couldn't match type ‘Maybe’ with ‘MaybeIO’
    Expected type: MaybeIO Mail
      Actual type: Maybe Mail
    In a stmt of a 'do' block: m <- getFirstMail i
    
    Couldn't match type ‘Maybe’ with ‘MaybeIO’
    Expected type: MaybeIO Header
      Actual type: Maybe Header
    In a stmt of a 'do' block: h <- getHeader m
\end{minted}
\end{frame}

\begin{frame}[fragile]
Wir brauchen also Konverter:
\begin{itemize}
 \item \texttt{Maybe -> MaybeIO}
 \item \texttt{IO -> MaybeIO}
\end{itemize}
\pause
Aber wir haben schon alles, was wir brauchen, wenn wir uns nur klar machen:
\begin{minted}{haskell}
return  :: Maybe a -> IO (Maybe a) -- return von IO
MaybeIO :: IO (Maybe a) -> MaybeIO a
\end{minted}
\pause
und
\begin{minted}{haskell}
Just      :: a -> Maybe a
fmap Just :: IO a -> IO (Maybe a)
\end{minted}
\end{frame}

\begin{frame}[fragile]
Somit wird unser Code von oben:
\begin{minted}{haskell}
f = do
     i <- MaybeIO (return (getInbox))
     MaybeIO (fmap Just (putStrLn "debug"))
     m <- MaybeIO (return (getFirstMail i))
     h <- MaybeIO (return (getHeader m))
     return h
\end{minted}
\pause
Zwar können wir nun do nutzen, aber das sieht doch eher hässlich aus. Außerdem ist so viel Code doppelt!
\end{frame}

\subsection{Finale Version}

\begin{frame}[fragile]
Wenn wir Muster finden, dann faktorisieren wir sie doch raus!
\begin{minted}{haskell}
liftMaybe :: Maybe a -> MaybeIO a
liftMaybe x = MaybeIO (return x)

liftIO :: IO a -> MaybeIO a
liftIO x = MaybeIO (fmap Just x)
\end{minted}
\pause
und wir erhalten:
\begin{minted}{haskell}
f = do
     i <- liftMaybe getInbox
     liftIO $ putStrLn "debug"
     m <- liftMaybe $ getFirstMail i
     h <- liftMaybe $ getHeader m
     return h
\end{minted}

\end{frame}


\end{document}