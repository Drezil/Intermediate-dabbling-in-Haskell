\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{graphicx} % Bilder
\usepackage{wrapfig} % Umflussbilder
\usepackage{multicol} % Multiple columns
\usepackage{minted} % Haskell source code
\usepackage{framed} % Frames around source code
\usepackage[framemethod=tikz]{mdframed} % Frames

\mdfdefinestyle{fancy}{
  roundcorner=5pt,
  linewidth=4pt,
  linecolor=red!80,
  backgroundcolor=red!20
}
\newmdenv[style=fancy]{important}

% Stuff for Beamer
\beamertemplatenavigationsymbolsempty
\usetheme{Warsaw}

\title{Intermediate Dabbling in Haskell}

\begin{document}

%  \usebackgroundtemplate{\includegraphics[width=\paperwidth,height=\paperheight]{1.jpg}} 
  
%----------------------------------------------------------------------------------------  

  \begin{frame}
  \begin{center}
    \Huge\textbf{Intermediate Functional Programming in Haskell}\\ \bigskip
    \LARGE Universität Bielefeld, Sommersemester 2015\\ \bigskip
    \large Jonas Betzendahl \& Stefan Dresselhaus
    \end{center}
  \end{frame}

%----------------------------------------------------------------------------------------  
\begin{frame}[allowframebreaks]{Outline}
\frametitle{Übersicht}
\tableofcontents[hideallsubsections]
\end{frame}

\section{Typen}
\subsection{Beispiele}
\begin{frame}
 Primitive Datentypen sind eine Annotation, wie die Bits im Speicher interpretiert werden sollen.\\
 \pause
 Einige primitive Datentypen sollten euch aus anderen Programmiersprachen schon bekannt sein:
 \begin{itemize}
  \item Zahlen (z.B. Int, Integer, Float, Double, ...)
  \item Zeichenketten (z.B. String, UTF-8-Strings, ...)
  \item Bool
 \end{itemize}
\end{frame}

\begin{frame}
 Es gibt auch Datentypen höherer Ordnung. Diese zeichnen sich dadurch aus, dass sie alleine nicht vollständig sind.\\
 \pause
 Auch hier sollten schon einige bekannt sein:\\
 (a,k,v steht hier jeweis für einen (primitiven) Datentypen)
 \begin{itemize}
  \item Liste von a
  \item Hashmap von k und v
  \item Vektor von a
  \item Tree von a
  \item Zusammengesetzte Typen (z.B. Structs in C/C++)
 \end{itemize}
 \pause
 Im folgenden gehen wir auf 2 wesentliche zusammengesetzte Typen in Haskell ein: Maybe und Either.
\end{frame}


\subsection{Maybe}
\begin{frame}[fragile]
 Einen neuen Datentypen definieren wir in Haskell mit dem Keyword \texttt{data}:
 \begin{minted}{haskell}
 data Maybe a = Nothing
              | Just a
 \end{minted}
 \pause
 Was hat das für einen Sinn?\\
 \pause
 Maybe gibt das Ergebnis einer Berechnung an, die fehlschlagen kann.\\
 In klassischen Sprachen wird hier meist ein \glqq abgesprochener\grqq \ Fehlerzustand zurückgegeben (0, -1, null, ...). In Haskell wird dies über den Rückgabetyp deutlich gemacht.
\end{frame}

\begin{frame}[fragile]
 Nachteile
 \begin{itemize}
  \item Ein neuer Datentyp, den man kennen muss
 \end{itemize}
 \pause
 Vorteile
 \begin{itemize}
  \item keine Absprachen, die man vergessen kann
  \item einheitliche Behandlung aller Fälle
  \item mehrere möglicherweise fehlschlagende Operationen gruppieren und nur solange evaluieren, bis die erste fehlschlägt oder alle erfolgreich sind
 \end{itemize}
\end{frame}

\begin{frame}[fragile]
 Beispiel: Finden eines Elementes in einer Liste
 \pause
 \begin{minted}{haskell}
 ghci > import Data.List
 ghci > findIndex (== 5) [1..10]
 Just 4               -- [1..10] !! 4 => 5
 
 ghci > findIndex (== 1000) [1..10]
 Nothing
 \end{minted}
 \pause
 Da wir \texttt{1000} in der Liste der Zahlen von 1-10 nicht finden können, haben wir keinen gültigen Index, daher bekommen wir ein Nothing.
\end{frame}

\subsection{Either}

\begin{frame}[fragile]
 \begin{minted}{haskell}
 data Either a b = Left a
                 | Right b
 \end{minted}
 \pause
 Was hat das für einen Sinn?\\
 \pause
 Either benutzt man, wenn man ein erwartetes Ergebnis \texttt{Right b} vom Typen \texttt{b} hat \textbf{oder} einen Fehlerzustand \texttt{Left a} vom Typen \texttt{a}.\\
 Meistens ist das erste Argument \texttt{String} um eine lesbare Fehlermeldung zu bekommen.\\
 \pause
 \bigskip
 Einfach zu merken: \glqq Right\grqq \ ist der \glqq richtige\grqq \ Fall.
\end{frame}

\begin{frame}[fragile]
 Beispiele für eine Benutzung von Either:
 \begin{minted}{haskell}
 parse5 :: String -> Either String Int
 parse5 "5" = Right 5
 parse5 _   = Left "Could not parse 5"
 
 parse5 "5"   -- Right 5
 parse5 "abc" -- Left "Could not parse 5"
 \end{minted}
\end{frame}

\section{Typklassen}
\begin{frame}
Viele Typen haben ähnliche oder gleiche Eigenschaften. Diese Eigenschaften fasst man zu Typklassen zusammen.\\
\pause
\begin{itemize}
 \item Zahlen kann man alle verrechnen, auch wenn z.B. Int und Double verschiedene Typen haben
 \item Listen, Vektoren, Arrays haben alle Elemente, über die man z.B. iterieren kann
 \item Maybe, Either, Listen, etc. haben (vielleicht) Elemente, die man verändern kann
\end{itemize}
\pause
\begin{important}
\textbf{Warnung:} Typklassen haben nichts mit den Klassen der Objektorientierung zu tun, sondern eher mit Templates und abstrakten Klassen
\end{important}
\end{frame}

\subsection{Beispiele}
\begin{frame}[fragile]
\begin{minted}{haskell}
class  Eq a  where
     (==) :: a -> a -> Bool
--or (/=) :: a -> a -> Bool

class Eq a => Ord a  where
     (<=) :: a -> a -> Bool
-- definiert automatisch: compare, >=, <, >, max, min
\end{minted}
\pause
Im folgenden stellen wir 3 Zentrale Typklassen vor: Functor, Applicative, Monad
\end{frame}

\subsection{Functor}
\begin{frame}[fragile]
 Ein Funktor F lässt sich auf jedem Datentypen definieren, der sowas wie einen \glqq Inhalt\grqq \ hat.\\
 \pause
 Genauer: Er wird definiert über die Funktion \texttt{fmap}, die es erlaubt eine Funktion auf den Inhalt anzuwenden.
 \begin{minted}{haskell}
class Functor f a where
    fmap :: (a -> b) -> f a -> f b
 \end{minted}
 \texttt{f} heisst hier \textbf{der Kontext}, in dem \texttt{a} existiert.\\
\pause
\bigskip
Spoiler: Liste ist ein Funktor. Maybe auch. Wieso?
\end{frame}

\begin{frame}[fragile]
Beispiel:
\begin{minted}{haskell}
ghci > fmap (+1) (Just 3)
       Just 4
ghci > fmap (+1) Nothing
       Nothing
ghci > fmap (+1) [1..10]
       [2,3,4,5,6,7,8,9,10,11]
ghci > fmap (+1) (Right 2)
       Right 3
ghci > fmap (+1) (Left 2)
       Left 2
\end{minted}
\end{frame}

\subsection{Applicative}
\begin{frame}[fragile]
Applicative funktioniert ähnlich zu Funktor. Hierbei kann man auch mit Funktionen in einem Kontext arbeiten.\\
\pause
\begin{minted}{haskell}
class Functor f => Applicative f where
    pure  :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{minted}
\pause
\texttt{pure} bringt etwas in den Standardkontext (z.B. Liste mit 1 Element, Just x, Right x, ..).\\
\texttt{<*>} ist fast ein \texttt{fmap}, nur dass die Funktion auch in demselben Kontext liegt.
\end{frame}

\begin{frame}[fragile]
Beispiel:
\begin{minted}{haskell}
ghci > import Control.Applicative
ghci > Just (+1) <*> Just 3
       Just 4
ghci > Nothging <*> Just 3
       Nothing
ghci > pure (+1) <*> Right 2
       Right 3
ghci > pure (+1) <*> Just 2
       Just 3
ghci > [(+1),(*2)] <*> [1..5]
       [2,3,4,5,6,2,4,6,8,10]
\end{minted}
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\subsection{do-notation}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Maybe}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Either}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Listen}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\subsection{List-Comprehension}
\begin{frame}
 foo
\end{frame}

\section{Praktische Arbeit}

\subsection{Case-Split}
\begin{frame}
 Wie kriege ich sachen aus einem f a? -> Alle Fälle behandeln mit case.
\end{frame}
\subsection{Maybe}
\begin{frame}
 Wie kriege ich sachen aus einem Maybe a? case x of Just a -> foo; Nothing -> bar
\end{frame}
\subsection{Either}
\begin{frame}
 Wie kriege ich sachen aus einem Either a? case x of Left a -> foo; Right b -> bar
\end{frame}





\end{document}