\documentclass{beamer}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[german]{babel}
\usepackage{graphicx} % Bilder
\usepackage{wrapfig} % Umflussbilder
\usepackage{multicol} % Multiple columns
\usepackage{minted} % Haskell source code
\usepackage{framed} % Frames around source code
\usepackage[framemethod=tikz]{mdframed} % Frames

\mdfdefinestyle{fancy}{
  roundcorner=5pt,
  linewidth=4pt,
  linecolor=red!80,
  backgroundcolor=red!20
}
\newmdenv[style=fancy]{important}

% Stuff for Beamer
\beamertemplatenavigationsymbolsempty
\usetheme{Warsaw}

\title{Intermediate Dabbling in Haskell}

\begin{document}

%  \usebackgroundtemplate{\includegraphics[width=\paperwidth,height=\paperheight]{1.jpg}} 
  
%----------------------------------------------------------------------------------------  

  \begin{frame}
  \begin{center}
    \Huge\textbf{Intermediate Functional Programming in Haskell}\\ \bigskip
    \LARGE Universität Bielefeld, Sommersemester 2015\\ \bigskip
    \large Jonas Betzendahl \& Stefan Dresselhaus
    \end{center}
  \end{frame}

%----------------------------------------------------------------------------------------  
\begin{frame}[allowframebreaks]{Outline}
\frametitle{Übersicht}
\tableofcontents[hideallsubsections]
\end{frame}

\section{Typen}
\subsection{Beispiele}
\begin{frame}
 Primitive Datentypen sind eine Annotation, wie die Bits im Speicher interpretiert werden sollen.\\
 \pause
 Einige primitive Datentypen sollten euch aus anderen Programmiersprachen schon bekannt sein:
 \begin{itemize}
  \item Zahlen (z.B. Int, Integer, Float, Double, ...)
  \item Zeichenketten (z.B. String, UTF-8-Strings, ...)
 \end{itemize}
\end{frame}

\begin{frame}
 Es gibt auch Datentypen höherer Ordnung. Diese zeichnen sich dadurch aus, dass sie alleine nicht vollständig sind.\\
 \pause
 Auch hier sollten schon einige bekannt sein:\\
 (a,k,v steht hier jeweis für einen (primitiven) Datentypen)
 \begin{itemize}
  \item Liste von a
  \item Hashmap von k und v
  \item Vektor von a
  \item Tree von a
  \item Zusammengesetzte Typen (z.B. Structs in C/C++)
 \end{itemize}
 \pause
 Im folgenden gehen wir auf 2 wesentliche zusammengesetzte Typen in Haskell ein: Maybe und Either.
\end{frame}


\subsection{Maybe}
\begin{frame}[fragile]
 Einen neuen Datentypen definieren wir in Haskell mit dem Keyword \texttt{data}:
 \begin{minted}{haskell}
 data Maybe a = Nothing
              | Just a
 \end{minted}
 \pause
 Was hat das für einen Sinn?\\
 \pause
 Maybe gibt das Ergebnis einer Berechnung an, die fehlschlagen kann.\\
 In klassischen Sprachen wird hier meist ein \glqq abgesprochener\grqq \ Fehlerzustand zurückgegeben (0, -1, null, ...). In Haskell wird dies über den Rückgabetyp deutlich gemacht.
\end{frame}

\begin{frame}[fragile]
 Nachteile
 \begin{itemize}
  \item Ein neuer Datentyp, den man kennen muss
 \end{itemize}
 \pause
 Vorteile
 \begin{itemize}
  \item keine Absprachen, die man vergessen kann
  \item einheitliche Behandlung aller Fälle
  \item mehrere möglicherweise fehlschlagende Operationen gruppieren und nur solange evaluieren, bis die erste fehlschlägt oder alle erfolgreich sind
 \end{itemize}
\end{frame}

\begin{frame}[fragile]
 Beispiel: Finden eines Elementes in einer Liste
 \pause
 \begin{minted}{haskell}
 ghci > import Data.List
 ghci > findIndex (== 5) [1..10]
 Just 4               -- [1..10] !! 4 => 5
 
 ghci > findIndex (== 1000) [1..10]
 Nothing
 \end{minted}
 \pause
 Da wir \texttt{1000} in der Liste der Zahlen von 1-10 nicht finden können, haben wir keinen gültigen Index, daher bekommen wir ein Nothing.
\end{frame}

\subsection{Either}

\begin{frame}
 foo
\end{frame}

\section{Typklassen}
\begin{frame}
 foo
\end{frame}

\subsection{Beispiele}
\begin{frame}
 foo
\end{frame}

\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\subsection{do-notation}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Maybe}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Either}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\section{Typklassen auf Listen}
\subsection{Functor}
\begin{frame}
 foo
\end{frame}

\subsection{Applicative}
\begin{frame}
 foo
\end{frame}

\subsection{Monad}
\begin{frame}
 foo
\end{frame}

\subsection{List-Comprehension}
\begin{frame}
 foo
\end{frame}

\section{Praktische Arbeit}

\subsection{Case-Split}
\begin{frame}
 Wie kriege ich sachen aus einem f a? -> Alle Fälle behandeln mit case.
\end{frame}
\subsection{Maybe}
\begin{frame}
 Wie kriege ich sachen aus einem Maybe a? case x of Just a -> foo; Nothing -> bar
\end{frame}
\subsection{Either}
\begin{frame}
 Wie kriege ich sachen aus einem Either a? case x of Left a -> foo; Right b -> bar
\end{frame}





\end{document}